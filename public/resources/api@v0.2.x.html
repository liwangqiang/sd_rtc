<!doctype html><html><head><meta charset="utf-8" /><style>pre{	font-family:"Times New Roman",Georgia,Serif;	font-size:150%;  }</style></head><body><pre>		version 0.2.1 <hr />				1、meetting				.supported			浏览器是否支持rtc  true or false 				.createStream(opt,  successCallback,  errorCallback)			opt  ==  {"video":true, "audio":true}			successCallback( stream )   	//得到一个 MediaStream 对象			errorCallback()					.attachStream(stream, video)			stream  ==  一个 MediaStream 对象			video  ==  DOM 元素 或者 标签id					.createClient(options)			options == {host: string}		//可选			return an rtc instance  											2、rtc				.register(id, cb)			id  ==  string类型  唯一			cb( isWorked )  			//isWorded == true or false 					.findRooms(query, cb)			query  ==  {} 				//是为了后期扩展，当前不支持。需要手动写一个空对象 {}			cb(err, rooms) 				//rooms == []   所有创建的房间			rooms[length] === {id: , name: ,limit: , owner: ,count: }								.me()			return who am i   			//如果未注册 为空					.create(opt, cb)			创建房间			opt  ==  {name: string, limit: number, owner: string}			cb(err, id) 				//id == 房间的id					.join(id, cb)			加入房间			id  ==  要加入的房间id			cb(err, room);				// room == room instance					.out()			退出房间					.chat(msg)			1、chat 可以给 room中的所有人发 				rtc.chat('send to all people in room');			2、给房间中特定的人 (未测试)				rtc.chat([id1, id2, id3], 'send to some people in room');		Event				[ 'room chat', 'personal chat']				1、rtc.on('room chat', cb(data)) 				2、rtc.on('personal chat', cb(data))				data == {from: userId, message: msgString}								3、room				.getId()			return id					.getName()			return name					.getLimit()			return limit					.getUserList()			return users == []					Event  			['user in', 'user out']			1、room.on('user in', cb(userId))			2、room.on('user out', cb(userId))											4、call				视频通话未实现		</pre>		</body></html>